//=========== Includes ===========
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <iomanip>
#include <sstream> 

#include <stdlib.h>
#include <termios.h>
#include <fcntl.h>
#include <unistd.h>

#include <chrono>
#include <ctime>

#include <GL/glut.h>

//=========== Declarations ===========
class Piece;
class LinkedNode;

unsigned int make_bitmap_text();
Piece randomPiece();
bool collision();
void draw_bitmap_text(const char* text);
void draw_stroke_text(const char* text);
void tetris();
void newPiece();
void movePiece();
void resetTempBoard();
void draw_Ghost_Block();
void draw_square(char c);
void holdPiece();
void cleanup();
void quitGame();
void toggleFullscreen();
void dropPiece();
void calculate_Ghost();
void updateBoard();
void color_Me(char c);


//=========== Shorthands ===========
using namespace std;

typedef chrono::high_resolution_clock Clock;
typedef chrono::milliseconds milliseconds;


//=========== Defines ===========
#define BOARD_WIDTH 10
#define BOARD_HEIGHT 20

#define SLEEP_TIME 500000 

#define WORLD_X 1920
#define WORLD_Y 1080

#define WINDOW_X 1280
#define WINDOW_Y 720

#define ASCII 100
#define VECTOR 200
#define THREE_D 300 


//================ DEBUG ================
int Y = 0;
int X = 0;

//=========== Globals ===========
char temp[BOARD_HEIGHT][BOARD_WIDTH];

int linesCleared;

int speed[21];

int score;
int level;

int pieceX;
int pieceY;

int graphics = VECTOR;

bool swapped;
bool holdInit;
bool gameOver;

bool FPS;

int frames;
int fps;
int FPSdisplay;

bool fullscreen;

long int elapsed;

int blockSize;

int aux_Box_S;

Clock::time_point start;
Clock::time_point lastMove;


LinkedNode* board;

//=========== Classes ===========
class LinkedNode 
{
private:
    LinkedNode* n;
    int* l;
    
public:
    LinkedNode* next() { return n; };
    int*        line() { return l; };
    
    void setNext(LinkedNode* next) { n = next; };
    void setLine(int * line)       { l = line; }
    
    
};

class Piece 
{
    
private:
    int h;
    int w;
    int** s;
    char i;
    
public:    
    void init(int** s_in,int h_in,int w_in, char i_in) {
	s = s_in;
	w = w_in;
	h = h_in;
	i = i_in;
    };
    
    void  setHeight(int h_in  ) { h = h_in;  };
    void  setWidth (int w_in  ) { w = w_in;  };
    void  setIcon  (char i_in ) { i = i_in;  };
    void  setShape (int** s_in) { s = s_in;  };
    
    int   height() { return h;  };
    int   width()  { return w;  };
    int   icon()   { return i;  };
    int** shape()  { return s;  }
    
} tetri_O, tetri_L, tetri_J, tetri_T, tetri_I, tetri_S, tetri_Z;

Piece current;
Piece hold;
Piece following;



//=============== Drawing Functions ===============
void draw_stroke_text(const char* text) 
{
	size_t len = strlen(text);
	
	int total_width = 0;
	
	for (size_t i=0;i<len;i++) {
		total_width += glutStrokeWidth(GLUT_STROKE_ROMAN, text[i]);
		glutStrokeCharacter(GLUT_STROKE_ROMAN, text[i]);
	}	
}

void displayFPS() 							
{
	glColor3f(1.0f, 1.0f, 0.0f); // set RGB values of colour to draw
    

	glPushMatrix(); //FPS
		glScalef(0.3f, 0.3f, 1.0f); // this will work
		glTranslatef(10, 10, 0.0f); // this will work
		
		
		string Result;          // string which will contain the result
		ostringstream convert;   // stream used for the conversion
		convert << fps;      // insert the textual representation of 'Number' in the characters in the stream
		Result = convert.str(); // set 'Result' to the contents of the stream
		
		draw_stroke_text(Result.c_str());
	glPopMatrix();	
	
}

void draw_square(char c) 
{
    
	glColor3f(0.0f, 0.0f, 0.0f); // set RGB values of colour to draw
    
	//printf('%c', c);
	
	switch((char) c) {
	    case 'T':
		glColor3f(1.0f, 0.0f, 1.0f); // purple
		break;
	    case 'J':
		glColor3f(0.0f, 0.0f, 1.0f); // blue
		break;
	    case 'I':
		glColor3f(0.0f, 1.0f, 1.0f); // light-blue
		break;
	    case 'Z':
		glColor3f(1.0f, 0.0f, 0.0f); // red
		break;
	    case 'S':
		glColor3f(0.0f, 1.0f, 0.0f); // green
		break;
	    case 'O':
		glColor3f(1.0f, 1.0f, 0.0f); // yellow
		break;
	    case 'L':
		glColor3f(1.0f, 0.5f, 0.0f); // orange
		break;
		
	    case 'G':
		draw_Ghost_Block();
		return;
	

	}
	
	static float vertex[4][2] =
		{
			{-1, 1},
			{1, 1},
			{1, -1},
			{-1, -1}
		};
	
	glBegin(GL_QUADS); 
		for (size_t i=0;i<4;i++) {
			
			glVertex2fv(vertex[i]);
		}
	glEnd();
	
	
	glColor3f(0.0f, 0.0f, 0.0f); // set RGB values of colour to draw
		
	glBegin(GL_LINE_LOOP); 
		for (size_t i=0;i<4;i++) {
			
			glVertex2fv(vertex[i]);
		}
	glEnd();
}

void draw_Border(int d_X, int d_Y, int size_X, int size_Y) 
{
    
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
     glBegin(GL_LINE_LOOP); 
	glVertex2i(d_X , d_Y );
	glVertex2i(d_X + size_X, d_Y);
	glVertex2i(d_X + size_X, d_Y + size_Y);
	glVertex2i(d_X , d_Y + size_Y);
    glEnd();   
    
}

void draw_Ghost_Block() 
{
    
	glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
	//printf('%c', c);
	
	
	static float vertex[4][2] =
		{
			{-1, 1},
			{1, 1},
			{1, -1},
			{-1, -1}
		};
	
	glBegin(GL_LINE_LOOP); 
		for (size_t i=0;i<4;i++) {
			
			glVertex2fv(vertex[i]);
		}
	glEnd();
}

void draw_Score() 
{
    glColor3f(1.0f, 1.0f, 0.0f); // set RGB values of colour to draw
    
    glPushMatrix(); //FPS
	glTranslatef(10, WORLD_Y - 40, 0.0f); // this will work
	glScalef(0.3f, 0.3f, 1.0f); // this will work
	
	string Result;          // string which will contain the result
	ostringstream convert;   // stream used for the conversion
	convert << score;      // insert the textual representation of 'Number' in the characters in the stream
	Result = convert.str(); // set 'Result' to the contents of the stream
	
	draw_stroke_text("Score: "); 
	draw_stroke_text(Result.c_str());
    glPopMatrix();	
}

void draw_Level() 
{
    glColor3f(1.0f, 1.0f, 0.0f); // set RGB values of colour to draw
    
    glPushMatrix(); //FPS
	
	glTranslatef(10, WORLD_Y - 80, 0.0f); // this will work
	glScalef(0.3f, 0.3f, 1.0f); // this will work
	
	string Result;          // string which will contain the result
	ostringstream convert;   // stream used for the conversion
	convert << level;      // insert the textual representation of 'Number' in the characters in the stream
	Result = convert.str(); // set 'Result' to the contents of the stream
	
	draw_stroke_text("Level: "); 
	draw_stroke_text(Result.c_str());
    glPopMatrix();
}

void draw_Next() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
    int d_X = WORLD_X / 5;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
     glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Next: "); 
	
    glPopMatrix();
    
    
    draw_Border(d_X - blockSize/2 - aux_Box_S/2, d_Y + blockSize/2, aux_Box_S, -aux_Box_S );
    
    
    d_X = WORLD_X / 5 + (-1) * blockSize;
    d_Y = 0 + 20 * blockSize - 1 - (5 - following.height()) * blockSize;
    
    for(int i = 0; i < following.height(); i++) {
	for(int j = 0; j < following.width(); j++) {
	    if(following.shape()[i][j] == 1) {
		glPushMatrix();

		    // translate it to where we want it
		    glTranslatef(d_X, d_Y, 0.0f);
		    
		    glScalef(blockSize/2, blockSize/2, blockSize/2);

		    
		    draw_square(following.icon());

			
		glPopMatrix(); // done with stack
	    }
	    d_X += blockSize;
	}
	d_Y -= blockSize;
	d_X = WORLD_X / 5 + (-1) * blockSize;
    }
}

void draw_Hold() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw   
    
    int d_X = WORLD_X / 5 * 4;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
    glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Hold: "); 
	
    glPopMatrix();
    
    draw_Border(d_X - blockSize/2 - aux_Box_S/2, d_Y + blockSize/2, aux_Box_S, -aux_Box_S );
    
    d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    d_Y = 0 + 20 * blockSize - 1 - (5 - hold.height()) * blockSize;
    
    for(int i = 0; i < hold.height(); i++) {
	for(int j = 0; j < hold.width(); j++) {
	    if(hold.shape()[i][j] == 1) {
		glPushMatrix();

		    // translate it to where we want it
		    glTranslatef(d_X, d_Y, 0.0f);
		    
		    glScalef(blockSize/2, blockSize/2, blockSize/2);

		    
		    draw_square(hold.icon());

			
		glPopMatrix(); // done with stack
	    }
	    d_X += blockSize;
	}
	d_Y -= blockSize;
	d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    }
}

void draw_Board() 
{
    int d_X = WORLD_X / 5 * 2;
    int d_Y = 0 + 22 * blockSize - 1 ;
    
    draw_Border(d_X - blockSize/2 - 1, d_Y + blockSize/2 + 1, 10 * blockSize + 2, (- 20 * blockSize) - 3);
    
    for(int i = 0; i < BOARD_HEIGHT ; i++) {
	glPushMatrix();
	
	glTranslatef(d_X, d_Y - i * blockSize, 0.0f);
	
	
	for(int j = 0; j < BOARD_WIDTH; j++) {
	    if(temp[i][j] != ' ') {
	    
		glPushMatrix();

		    // translate it to where we want it
		    glTranslatef(0 + j * blockSize, 0, 0.0f);
		    
		    // scale it up 
		    //glScalef(1.0f, 1.0f, 1.0f);
		    glScalef(blockSize/2, blockSize/2, blockSize/2);

		    // rotate anticlockwise in-plane by 30 degrees
		    glRotatef(0.0f, 0.0f, 0.0f, 1.0f); 
		    
		    draw_square(temp[i][j]);
		    
		glPopMatrix(); // done with stack

	    }	    
	}
	glPopMatrix(); // done with stack
    }
}


void draw_ASCII_Next() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
    int d_X = WORLD_X / 5;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
     glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Next: "); 
	
    glPopMatrix();
        
    
    d_X = WORLD_X / 5 + (-1) * blockSize;
    d_Y = 0 + 21 * blockSize - 1 - (5 - following.height()) * blockSize;
    
    
    for(int j = 0; j < following.width(); j++) {
	  
	glPushMatrix();

	    glTranslatef(d_X + blockSize * j, d_Y, 0.0f);
	    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
	    draw_stroke_text("-") ;
    
	glPopMatrix(); // done with stack
    }
    
     d_Y -= blockSize;
     d_X = WORLD_X / 5 + (-1) * blockSize;
    
    for(int i = 0; i < following.height(); i++) {
	
	//char buffer[4];
	//buffer[0] = '[';
	//buffer[1] = ']';
	//buffer[2] = '\0';
	
	//draw_stroke_text(buffer) ;
	
	glPushMatrix();
	
	glTranslatef(d_X, d_Y - i * blockSize, 0.0f);
	
	
	
	for(int j = 0; j < following.width(); j++) {
	    if(following.shape()[i][j] == 1) {
		glPushMatrix();
		    glTranslatef(0 + j * blockSize, 0, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);

			color_Me(following.icon());

			draw_stroke_text("[]") ;

		glPopMatrix(); // done with stack
	    }
	}
	glPopMatrix();
    }
    
    
    d_Y -= blockSize * (following.width() + 1);
    d_X = WORLD_X / 5 + (-1) * blockSize;
    
    for(int j = 0; j < following.width(); j++) {
	    
	    glPushMatrix();
		    glTranslatef(d_X, d_Y, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);

		    draw_stroke_text("-") ;

			    
	    glPopMatrix(); // done with stack
	    
	    d_X += blockSize;
	}
    
     
    
}

void draw_ASCII_Hold() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw   
    
    int d_X = WORLD_X / 5 * 4;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
    glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Hold: "); 
	
    glPopMatrix();
    
    
    
    
    
    
    d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    d_Y = 0 + 20 * blockSize - 1 - (5 - hold.height()) * blockSize;
    
    for(int i = 0; i < hold.height(); i++) {
	for(int j = 0; j < hold.width(); j++) {
	    if(hold.shape()[i][j] == 1) {
		glPushMatrix();
		
		    glTranslatef(d_X, d_Y, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		
		    color_Me(hold.icon());
		    draw_stroke_text("[]") ;
			
		glPopMatrix(); // done with stack
	    }
	    d_X += blockSize;
	}
	d_Y -= blockSize;
	d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    }
}

void draw_ASCII_Board() {
    
    int d_X = WORLD_X / 5 * 2 - blockSize;
    int d_Y = 0 + 22 * blockSize - 1 ;
   
    char buffer[4];
   
    for(int i = 0; i < BOARD_HEIGHT + 1 ; i++) {
	
	glPushMatrix();
	    glTranslatef(d_X, d_Y - i * blockSize, 0.0f);
	    
	    glPushMatrix();    
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		
		draw_stroke_text("<!") ;
	    glPopMatrix();
			    
	    for(int j = 0; j < BOARD_WIDTH; j++) {
		
		glTranslatef(blockSize, 0, 0.0f);
		
		glPushMatrix();
		    
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		    
		    if(i >= BOARD_HEIGHT) {
			buffer[0] = '=';
			buffer[1] = '\0';
		    } else {
			if(temp[i][j] == ' ') {

			    buffer[0] = ' ';
			    buffer[1] = '.';
			    buffer[2] = '\0';
			} else {
			    
			    buffer[0] = '[';
			    buffer[1] = ']';
			    buffer[2] = '.';
			    buffer[3] = '\0';
			    //buffer[0] = temp[i][j];
			    
			    color_Me(temp[i][j]);
			    
			    if(temp[i][j] == 'G') {
				buffer[0] = '#';
				buffer[1] = '.';
				buffer[2] = '\0';
			    }   
			}
		    }
		    
		    draw_stroke_text(buffer) ;
		    
		    glColor3f(1.0f, 1.0f, 1.0f);
			
		    glPopMatrix();
		
	    }
	    glPushMatrix();

		glTranslatef( blockSize, 0, 0.0f);
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
			    
		draw_stroke_text("!>") ;
				    
	    glPopMatrix();
	
	glPopMatrix();
    }
   
    glPushMatrix();
	
	glTranslatef(d_X, d_Y - 21 * blockSize, 0.0f);
	
	for(int j = 0; j < BOARD_WIDTH; j++) {
	    
	    glPushMatrix();  
		glTranslatef(0 + (j + 1) * blockSize, 0, 0.0f);
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		    
		draw_stroke_text("\\/") ;
		    
	    glPopMatrix(); 
	}

    glPopMatrix();
	    
}

void color_Me(char c) {
    
    switch(c) {
	case 'T':
	    glColor3f(1.0f, 0.0f, 1.0f); // purple
	    break;
	case 'J':
	    glColor3f(0.0f, 0.0f, 1.0f); // blue
	    break;
	case 'I':
	    glColor3f(0.0f, 1.0f, 1.0f); // light-blue
	    break;
	case 'Z':
	    glColor3f(1.0f, 0.0f, 0.0f); // red
	    break;
	case 'S':
	    glColor3f(0.0f, 1.0f, 0.0f); // green
	    break;
	case 'O':
	    glColor3f(1.0f, 1.0f, 0.0f); // yellow
	    break;
	case 'L':
	    glColor3f(1.0f, 0.5f, 0.0f); // orange
	    break;    
    }
}

//===================== Callbacks =====================
void display() 
{
    frames++;
    
    glClear(GL_COLOR_BUFFER_BIT);	//clears to current background colour
    
    if (FPS) displayFPS();
    
    switch(graphics) {
	case VECTOR:
	    draw_Score();
	    draw_Level();
    
	    draw_Next();
	    draw_Hold();
	    
	    draw_Board();
	    break;
	case ASCII:
	    draw_Score();
	    draw_Level();
	    
	    draw_ASCII_Next();
	    draw_ASCII_Hold();
	    
	    draw_ASCII_Board();
	    break;
	case THREE_D:
	    break;
    }
    
    glutSwapBuffers(); 
}

void idle() 
{

	Clock::time_point now = Clock::now();
	
	milliseconds ms = chrono::duration_cast<milliseconds>(now - start);
	
	elapsed = ms.count();
	
	if( elapsed >= FPSdisplay) {
		//cout<<frames/elapsed<<"\n";
		fps = frames;
		frames = 0;
		start = Clock::now();
		glutPostRedisplay();
		return;
	}
    

    
    ms = chrono::duration_cast<milliseconds>(now - lastMove);
    int elapsed = ms.count();
    
    
   
	
    if(elapsed > speed[level]) {
	lastMove = Clock::now();
	
	pieceY++;
	movePiece();
	
	glutPostRedisplay();
	return;
	    
    }
    
    glutPostRedisplay();
    
    
}


//===================== Setup =====================
void initGL() 
{
    fullscreen = false;
    
    FPS = true;
    
    frames = 0;
    fps = 0;
    FPSdisplay = 1000;
    
    // select viewing transformation matrix to modify
    glMatrixMode(GL_PROJECTION); 

    // set identity on matrix
    glLoadIdentity();

    // specify bottom-left and top-right corners
    // of window in world coordinates
    // takes LEFT, RIGHT, BOTTOM, TOP
    gluOrtho2D(0, WORLD_X, 0, WORLD_Y);

    // set background colour and transparency
    // takes RGBA values
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // black	
}

int** allocateArray(int height, int width) 
{
    
    int** p = ( int** ) malloc( height *sizeof( int* ));
	for ( int i = 0; i < height; i++ ) {
	    p[i] = ( int* ) malloc( width * sizeof(int) );	
	}
    return p;
}

void gameInit() 
{
    blockSize = WORLD_X / 5 / 10;

    aux_Box_S = 5 * blockSize;
    
    
    level = 0;
    
    speed[0] = 53 / 60.0 * 1000;
    speed[1] = 49 / 60.0 * 1000;
    speed[2] = 45 / 60.0 * 1000;
    speed[3] = 41 / 60.0 * 1000;
    speed[4] = 37 / 60.0 * 1000;
    speed[5] = 33 / 60.0 * 1000;
    speed[6] = 28 / 60.0 * 1000;
    speed[7] = 22 / 60.0 * 1000;
    speed[8] = 17 / 60.0 * 1000;
    speed[9] = 11 / 60.0 * 1000;
    speed[10] = 10 / 60.0 * 1000;
    speed[11] = 9 / 60.0 * 1000;
    speed[12] = 8 / 60.0 * 1000;
    speed[13] = 7 / 60.0 * 1000;
    speed[14] = 6 / 60.0 * 1000;
    speed[15] = 6 / 60.0 * 1000;
    speed[16] = 5 / 60.0 * 1000;
    speed[17] = 5 / 60.0 * 1000;
    speed[18] = 4 / 60.0 * 1000;
    speed[19] = 4 / 60.0 * 1000;
    speed[20] = 3 / 60.0 * 1000;
    
    
    linesCleared = 0;
    
    lastMove = Clock::now();
    
    holdInit = false;
    gameOver = false;
    
    LinkedNode* node = new LinkedNode;
    board = node;
    
    
    for(int i = 0; i < BOARD_HEIGHT; i++) {
	
	int* line = (int*) malloc(BOARD_WIDTH * sizeof(int));
	
	for(int j = 0; j < BOARD_WIDTH; j++) {
	    line[j] = ' ';
	    temp[i][j] = ' ';
	}
	
	node->setLine(line);
	node->setNext(new LinkedNode);
	
	node = node->next();
	
    }
    
    //int* line = (int*) malloc(BOARD_WIDTH * sizeof(int));
    //node->setLine(line);
  
      
    int height;
    int width;
    char icon;
    
    
    
    
    
	height = 2;
	width = 2;
	
	int** shape_O = allocateArray(height, width);
	
	
	shape_O[0][0] = 1; shape_O[0][1] = 1;
	shape_O[1][0] = 1; shape_O[1][1] = 1;
	
	icon = 'O';
	

    tetri_O.init(shape_O, height, width, icon);
    
		
	height = 4;
	width = 4;
	
	int** shape_I = allocateArray(height, width);
	
	shape_I[0][0] = 0; shape_I[0][1] = 1; shape_I[0][2] = 0;  shape_I[0][3] = 0;
	shape_I[1][0] = 0; shape_I[1][1] = 1; shape_I[1][2] = 0;  shape_I[1][3] = 0;
	shape_I[2][0] = 0; shape_I[2][1] = 1; shape_I[2][2] = 0;  shape_I[2][3] = 0;
	shape_I[3][0] = 0; shape_I[3][1] = 1; shape_I[3][2] = 0;  shape_I[3][3] = 0;
    
    tetri_I.init(shape_I, height, width, 'I');
    
    
	height = 3;
	width = 3;
	
	int** shape_L = allocateArray(height, width);
	
	shape_L[0][0] = 0; shape_L[0][1] = 1; shape_L[0][2] = 0;
	shape_L[1][0] = 0; shape_L[1][1] = 1; shape_L[1][2] = 0;
	shape_L[2][0] = 0; shape_L[2][1] = 1; shape_L[2][2] = 1;
	
    
    tetri_L.init(shape_L, height, width, 'L');
    
    
	height = 3;
	width = 3;
	
	int** shape_J = allocateArray(height, width);
	
	shape_J[0][0] = 0; shape_J[0][1] = 1; shape_J[0][2] = 0;
	shape_J[1][0] = 0; shape_J[1][1] = 1; shape_J[1][2] = 0;
	shape_J[2][0] = 1; shape_J[2][1] = 1; shape_J[2][2] = 0;
	
    
    tetri_J.init(shape_J, height, width, 'J');
        
    	height = 3;
	width = 3;
	
	int** shape_T = allocateArray(height, width);
	
	shape_T[0][0] = 0; shape_T[0][1] = 1; shape_T[0][2] = 0; 
	shape_T[1][0] = 1; shape_T[1][1] = 1; shape_T[1][2] = 1;
	shape_T[2][0] = 0; shape_T[2][1] = 0; shape_T[2][2] = 0;		


    tetri_T.init(shape_T, height, width, 'T');
      
    
    	height = 3;
	width = 3;
	
	int** shape_Z = allocateArray(height, width);
	
	shape_Z[0][0] = 1; shape_Z[0][1] = 1; shape_Z[0][2] = 0;
	shape_Z[1][0] = 0; shape_Z[1][1] = 1; shape_Z[1][2] = 1;

    
    tetri_Z.init(shape_Z, height, width, 'Z');
    
    
    	height = 3;
	width = 3;
	
	int** shape_S = allocateArray(height, width);
	
	shape_S[0][0] = 0; shape_S[0][1] = 0; shape_S[0][2] = 0;
	shape_S[1][0] = 0; shape_S[1][1] = 1; shape_S[1][2] = 1;
	shape_S[2][0] = 1; shape_S[2][1] = 1; shape_S[2][2] = 0;
    
    tetri_S.init(shape_S, height, width, 'S');
    
    
    
    srand (time(NULL));
    
    current = randomPiece();
    
    following = randomPiece();
    
    pieceY = 0 - current.height();
    pieceX = BOARD_WIDTH / 2;
    
    swapped = false;
    
}

void restart() 
{
    
    level = 0;
    score = 0;
    
    linesCleared = 0;
    
    holdInit = false;
    gameOver = false;
    
    
    LinkedNode* node = board;

    
     
   for(int i = 0; i < BOARD_HEIGHT; i++) {
	for(int j = 0; j < BOARD_WIDTH; j++) {
	   
		temp[i][j] = ' ';
		node->line()[j] = ' ';

	}
	
	node = node->next();
    }   
    
    current = randomPiece();
    
    following = randomPiece();
    
    pieceY = 0 - current.height();
    pieceX = BOARD_WIDTH / 2;
    
    swapped = false;
}

void freeArray(int** p, int height, int width) 
{
   
    for ( int i = 0; i < height; i++ ) {
	free(p[i]);	
    }
	
    free(p);
}

void cleanup() 
{
    
    LinkedNode* current = board;
    LinkedNode* next = board;
    
    for(int i = 0; i < BOARD_HEIGHT; i++) {	
	
	next = current->next();
	free(current);
	current = next;
    }
    
    freeArray(tetri_O.shape(), tetri_O.height(), tetri_O.width());
    
    freeArray(tetri_I.shape(), tetri_I.height(), tetri_I.width());
    
    freeArray(tetri_L.shape(), tetri_L.height(), tetri_L.width());
    
    freeArray(tetri_J.shape(), tetri_J.height(), tetri_J.width());
    
    freeArray(tetri_T.shape(), tetri_T.height(), tetri_T.width());
    
    freeArray(tetri_Z.shape(), tetri_Z.height(), tetri_Z.width());
    
    freeArray(tetri_S.shape(), tetri_S.height(), tetri_S.width());
    
    
    
    
    
}


//=========== Game Functions ===========
void updateTemp()
{
    
    for(int i = 0; i < current.height(); i++) {
	for(int j = 0; j < current.width(); j++) {
	    //sanity check
	    if(
		pieceY + i >= 0 &&
		pieceY + i < BOARD_HEIGHT &&
		pieceX + j >= 0 && 
		pieceX + j < BOARD_WIDTH
	    ) {
		if(current.shape()[i][j] == 1) {
		    temp[pieceY + i][pieceX + j] = current.icon();
		}
	    } 
	}
    }
}

void movePiece()
{
    resetTempBoard();
    
    if(collision()) {	//place the piece and generate a new one
	pieceY--;
	
	if(pieceY < 0 ){
	    gameOver = true;
	    printf("Game Over\n");
	    restart();
	    
	    return;
	}
	
	updateBoard();
	updateTemp();
	
	newPiece();
	
    } else {  //update the draw array
    
	updateTemp();
    }
    
    calculate_Ghost();
}

void resetTempBoard()
{
    
   LinkedNode* node = board;
  
   for(int i = 0; i < BOARD_HEIGHT; i++) {
	for(int j = 0; j < BOARD_WIDTH; j++) {
	   
		temp[i][j] = node->line()[j];

	}
	
	node = node->next();
    }   
       
}

void newPiece()
{
    
    current = following;
    
    following = randomPiece();
  
    pieceY = 0 - current.height();
    pieceX = BOARD_WIDTH / 2 - current.width();
        
    swapped = false;
}

void rotateRight()
{
    
    int w = current.width();
    int h = current.height();
    
    
    int** shape_r = ( int** ) malloc( w *sizeof( int* ));
    for ( int i = 0; i < w; i++ ) {
	shape_r[i] = ( int* ) malloc( h * sizeof(int) );	
    }
    
    for(int i = 0; i < h; i++) {
	for(int j = 0; j < w; j++) {
	    shape_r[j][i] = current.shape()[i][j];
	}
    }
    
    /*
    int aux;
    for(int i = 0; i < h; i++) {
	aux = shape_r[0][i];
	shape_r[0][i] = shape_r[w-1][i];
	shape_r[w-1][i] = aux;
    }
    */
    
    int aux;
    for(int i = 0; i < w; i++) {
	aux = shape_r[i][0];
	shape_r[i][0] = shape_r[i][h -1];
	shape_r[i][h - 1] = aux;
    }
    

    
    
    //freeArray(current.shape(), h, w);
    
    current.setShape(shape_r);
    current.setHeight(w);
    current.setWidth(h);
    
   
   if(collision()) {
	
	
	
	for(int y = 0; y > -3; y--) {
	    for(int x = -2; x < 3; x++) {
		pieceY += y;
		pieceX += x;
		
		if(!collision()) {
		    return;
		} 
		
		pieceY -= y;
		pieceX -= x;
	    }
	}	    	
	
	for(int y = 1; y < 3; y++) {
	    for(int x = -2; x < 3; x++) {
		pieceY += y;
		pieceX += x;
		
		if(!collision()) {
		    return;
		} 
	    
		pieceY -= y;
		pieceX -= x;
	    }
	}
    }
    
    while(collision()) {
	pieceY--;   
   }
    
}

void rotateLeft()
{
    
    int w = current.width();
    int h = current.height();
    
    
    int** shape_r = ( int** ) malloc( w *sizeof( int* ));
    for ( int i = 0; i < w; i++ ) {
	shape_r[i] = ( int* ) malloc( h * sizeof(int) );	
    }
    
    for(int i = 0; i < h; i++) {
	for(int j = 0; j < w; j++) {
	    shape_r[j][i] = current.shape()[i][j];
	}
    }
    
    
   
    int aux;
    for(int i = 0; i < h; i++) {
	aux = shape_r[0][i];
	shape_r[0][i] = shape_r[w-1][i];
	shape_r[w-1][i] = aux;
    }
    
    
    //freeArray(current.shape(), h, w);
    
    current.setShape(shape_r);
    current.setHeight(w);
    current.setWidth(h);
    
    
   if(collision()) {
	
	for(int x = -2; x < 3; x++) {
	    for(int y = -2; y < 3; y++) {
		pieceY += y;
		pieceX += x;
		
		if(!collision()) {
		    return;
		} 
		
		pieceY -= y;
		pieceX -= x;
	    }
	}	    	
    }
   
   while(collision()) {
	pieceY--;   
   }
    
}

void holdPiece()
{
    if(swapped) {
	return;
    } else { 
	swapped = true;
    if (holdInit) {
	    Piece aux;
	    aux = hold;
	    hold = current;
	    current = aux;
	    
	    pieceY = 0 - current.height();
	    pieceX = BOARD_WIDTH / 2;

	} else {
	    
	    hold = current;
	    
	    newPiece();
	    
	    holdInit = true;
	}
    }
    
}

Piece randomPiece() 
{
      /* generate secret number between 1 and 10: */
    int r = rand() % 7 + 1;
    
     switch(r) {
	
	case 1:
	   return tetri_I;
	case 2:
	    return tetri_L;
	case 3:
	    return tetri_J;    
	case 4:
	    return tetri_O;
	case 5:
	    return tetri_S;	    
	case 6:
	    return tetri_Z;
	    break;
	case 7:
	    return tetri_T;
	    
    }
}

void quitGame()
{
   //are you sure?
   //glutDestroyWindow ( Win.id );
   cleanup();
   exit(0); // quit! 
}

void calculate_Ghost() 
{
    //does the piece not fit on the board
    
    //did the piece touch another piece
    
    int ghostY = pieceY;
    
    LinkedNode* node = board;
		    
    for(int i = 0; i < ghostY; i++) {	
	node = node->next();
    } 
		    
    do {
	ghostY++;
	
	//check for collisions
	bool collision = false;
	LinkedNode* node = board;
	
	for(int i = 0; i < ghostY; i++) {	
	    node = node->next();
	}   
	
	int diff = 0;
	
	if(ghostY < 0) {
	    diff = ghostY;
	}
	    
	
	for(int i = 0; i < current.height() + diff; i++) {
	    for(int j = 0; j < current.width(); j++) {
		if(
		    ghostY + i >= 0 &&
		    pieceX + j >= 0 && 
		    pieceX + j < BOARD_WIDTH
		) {
		    if(current.shape()[i][j] == 1 && node->line()[pieceX + j] != ' ') {
			collision = true;
		    }
		    
		    if(ghostY + i >= BOARD_HEIGHT && current.shape()[i][j] == 1) {
			collision = true;
		    }
		} 	
	    }
	    
	    node = node->next();
	}
	
	if(collision) {
	    ghostY--;
	    
	    
	    for(int i = 0; i < current.height(); i++) {
		for(int j = 0; j < current.width(); j++) {
		    if(
			ghostY + i >= 0 &&
			ghostY + i < BOARD_HEIGHT &&
			pieceX + j >= 0 && 
			pieceX + j < BOARD_WIDTH
		    ) {
			if(current.shape()[i][j] == 1) {
			    if(temp[ghostY + i][pieceX + j] != current.icon()) temp[ghostY + i][pieceX + j] = 'G';
			}
		    } 
		}
	    }
	    
	    return;
	}
	
			    
    } while (ghostY != 0 - current.height());
				
}

bool collision()
{
    LinkedNode* node = board;
    
    for(int i = 0; i < pieceY; i++) {	
	node = node->next();
    }   
    
    int diff = 0;
    
    if(pieceY < 0) {
	diff = pieceY;
    }
	
    
    for(int i = 0; i < current.height() + diff; i++) {
	for(int j = 0; j < current.width(); j++) {
	    
	    if(current.shape()[i][j] == 1) {
		
		if(pieceY + i >= BOARD_HEIGHT) {
		    return true;
		}
		
		if (pieceX + j < 0 || pieceX + j >= BOARD_WIDTH) {
		    return true;
		}

		
		if(pieceY + i >= 0 && node->line()[pieceX + j] != ' ') {
		    printf("FLAG\n");
		    return true;
		}
	    }
	}
	
	node = node->next();
    }   
    
    return false;
    
}

void updateBoard()
{
         
   LinkedNode* node = board;
   LinkedNode* prev = board;
   
   int linesComepleted = 0;
    
   for(int i = 0; i < pieceY; i++) {	
	prev = node;
	node = node->next();
    }   
    
    
    for(int i = 0; i < current.height(); i++) {
	
	for(int j = 0; j < current.width(); j++) {
	    if(current.shape()[i][j] == 1) {
		node->line()[pieceX + j] = current.icon();
			
	    }
	}
	
	bool complete = true;
	    
	for(int k = 0; k < BOARD_WIDTH; k++) {
	    printf("%c", node->line()[k]);
	    if(node->line()[k] == 32) {
		
		complete = false;
		break;
	    } 
	    
	}
	printf("\n");
	
	if(complete) {
	    
	    
	    linesComepleted++;
	    
	    prev->setNext(node->next());
	    
	    int* line = (int*) malloc(BOARD_WIDTH * sizeof(int));
	    
	    for(int t = 0; t < BOARD_WIDTH; t++) {
		line[t] = ' ';
	    }
	    
	    LinkedNode* n = (LinkedNode*) new LinkedNode;
	    n->setNext(board);
	    n->setLine(line);
	    
	    board = n;
	    
	} else {
	    prev = node;
	}
	
	if (pieceY + i >= BOARD_HEIGHT - 1) {
	    break;
	} else {
	    node = node->next();
	}
	
    }
    
    switch(linesComepleted) {
	
	case 1: 
	    score += 40 * (level + 1);
	    break;
	case 2:
	    score += 100 * (level + 1);
	    break;
	case 3:
	    score += 300 * (level + 1);
	    break;
	case 4:
	    score += 1200 * (level + 1);
	    break;
	
    }
    
    linesCleared += linesComepleted;
    
    if(linesCleared > 10) {
	linesCleared = 0;
	level++;
	
	if(level > 20) {
	    printf("You Win!\n");
	    restart();		
	}
    }	    
}

void dropPiece() 
{
    LinkedNode* node = board;

    while(1)
    {
	pieceY++;
	if(collision()) break;
	
	score += 2;
	movePiece();    
    }
    
   
    
    resetTempBoard();   
   
}

void moveDown() 
{	
    pieceY++;   
    score++;
}

void moveLeft() 
{
    
    LinkedNode* node = board;
    
    
    for(int i = 0; i < pieceY; i++) {	
	node = node->next();
    }   
	 	    
    for(int i = 0; i < current.height(); i++) {
	for(int j = 0; j < current.width(); j++) {
	    if(pieceX - 1 + j >= 0 ) {
		if(current.shape()[i][j] == 1 && node->line()[pieceX - 1 + j] != ' ') {
		    //printf("DENIED\n");
		    return;
		}
	    } else {
		if(current.shape()[i][j] == 1) {
		    return;
		}
	    }
	}
	node = node->next();
    }
	        
    pieceX--;
}

void moveRight() 
{
    LinkedNode* node = board;
    
    for(int i = 0; i < pieceY; i++) {	
	node = node->next();
    }   
    
    for(int i = 0; i < current.height(); i++) {
	for(int j = 0; j < current.width(); j++) {
	    if(pieceX + 1 + j < BOARD_WIDTH ) {
		if(current.shape()[i][j] == 1 && node->line()[pieceX + 1 + j] != ' ') {
		    return;
		}    
	    } else if(current.shape()[i][j] == 1) {
		return;
	    }
	}
	node = node->next();
    }
    
    pieceX++;
}

//===================== Input =====================

void keyboard(unsigned char key, int x, int y) 
{ // will get which key was pressed and x and y positions if required	
	
	switch (key)
	{
		case 27: //ESC
		    quitGame();
		    break;
		case 'q': 
		    quitGame();
		    break;
		case 'r': 
		    restart();
		    break;
		
		    
		case 'f': 
		    toggleFullscreen();
		    break;
		    
		
		case 'z': 
		    holdPiece();
		    break;
		case 'x': 
		    rotateRight();
		    break;
		case 'c': 
		    rotateLeft();
		    break;
		    
		
		    
		case ' ': 
		    dropPiece();
		    break;
		    
		    
		case 'i': 
		    graphics = ASCII;
		    break;
		case 'o': 
		    graphics = VECTOR;
		    break;    
		case 'p': 
		    graphics = THREE_D;
		    break;
		    
	}

	movePiece();
	
	glutPostRedisplay();
}

void toggleFullscreen() 
{    
    if(!fullscreen){
	glutFullScreen();
	fullscreen = true;
    } else if(fullscreen){
	glutReshapeWindow(WINDOW_X, WINDOW_Y);
	glutPositionWindow(100,100);
	fullscreen = false;
    }       
}

void special(int key, int, int) 
{ //keys such as arrow keys
	// handle special keys
    
	switch (key)
	{
	  
	    case GLUT_KEY_RIGHT: 
		moveRight();
		break;
		
	    case GLUT_KEY_LEFT:
		moveLeft();
		break;
	    case GLUT_KEY_DOWN: 
		moveDown();
		break;
	    case GLUT_KEY_UP: 
		rotateRight();
		break;
		
	    case GLUT_KEY_HOME: 
		holdPiece();
		break;
		
		
	}
	movePiece();
	glutPostRedisplay(); // force a redraw
	
}

void mouse_click(int button, int state, int x, int y) 
{
    
    
	if (button==GLUT_LEFT_BUTTON) {
	    
		std::cerr << "\t left mouse button pressed!" << std::endl;
		
		if (state==GLUT_UP)
		{
			std::cerr << "\t button released...click finished" << std::endl;

		}

	} else if (button==GLUT_RIGHT_BUTTON) {
		std::cerr << "\t right mouse button pressed!" << std::endl;
		if (state==GLUT_UP) {
			std::cerr << "\t button released...click finished" << std::endl;

		}
	}
	
	glutPostRedisplay();
}

void mouse_motion(int x, int y) 
{
	//std::cerr << "\t mouse is at (" << x << ", " << y << ")" << std::endl;
	//glutPostRedisplay();
}

//=================== Main ===================
int main (int argc, char* argv[]) 
{
  
    //initialise glut
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA); // flags bitwise OR'd together
     
    // display window size is in pixels on screen
    glutInitWindowSize(WINDOW_X, WINDOW_Y); 
    glutInitWindowPosition(50, 50); 
    glutCreateWindow("I am glut");
    
    //callback functions
    glutDisplayFunc(display);
    glutIdleFunc(idle);
    
    glutKeyboardFunc(keyboard); 
    glutSpecialFunc(special);
    
    glutMouseFunc(mouse_click); 
    glutPassiveMotionFunc(mouse_motion); 
    
    //initialise program
    initGL();
    gameInit();
    
    //enter infinite loop
    glutMainLoop();
    
    return 0;
  
}