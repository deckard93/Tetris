//=========== Includes ===========
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <iomanip>
#include <sstream> 

#include <stdlib.h>
#include <termios.h>
#include <fcntl.h>
#include <unistd.h>

#include <chrono>
#include <ctime>

#include <GL/glut.h>

#include "png_load.h"


//=========== Declarations ===========
class Piece;
class LinkedNode;

unsigned int make_bitmap_text();
Piece randomPiece();
int draw_center_text(const char* text);
void draw_bitmap_text(const char* text);
void draw_stroke_text(const char* text);
void tetris();
void newPiece();
void movePiece();
void resetTempBoard();
void draw_Ghost_Block();
void draw_square(char c);
void holdPiece();
void cleanup();
void quitGame();
void toggleFullscreen();
void dropPiece();
void calculate_Ghost();
void updateBoard();
void color_Me(char c);
void toggleFPS();
void draw_filled_square();
void toggleTextures();
void initGL();
void restart();
bool collision();


//=========== Shorthands ===========
using namespace std;

typedef chrono::high_resolution_clock Clock;
typedef chrono::milliseconds milliseconds;


//=========== Defines ===========
#define BOARD_WIDTH 	10
#define BOARD_HEIGHT 	20

#define SLEEP_TIME 500000 

#define ASCII 	100
#define VECTOR 	200
#define THREE_D 300

#define MAINMENU 1000 
#define HOWTO    2000
#define SETTINGS 3000

#define PLAYING  4000

#define PAUSED   5000
#define GAMEOVER 6000
#define YOUWIN	 7000



//================ DEBUG ================
int Y = 0;
int X = 0;

//=========== Globals ===========
char temp[BOARD_HEIGHT][BOARD_WIDTH];

int linesCleared;

int WORLD_X = 1920;
int WORLD_Y = 1080;


int WINDOW_X = 1280;
int WINDOW_Y = 720;

int speed[21];

int gameState;

int score;
int level;

int startLevel;
int endLevel;

int pieceX;
int pieceY;

int cursorX;
int cursorY;

int graphics = VECTOR;

bool swapped;
bool holdInit;
bool gameOver;

bool FPS;

int frames;
int fps;
int FPSdisplay;

bool fullscreen;
bool texture = false;

long int elapsed;

int blockSize;

int aux_Box_S;

unsigned int howto; // texture handle


Clock::time_point start;
Clock::time_point lastMove;


LinkedNode* board;

//=========== Classes ===========
class LinkedNode 
{
private:
    LinkedNode* n;
    int* l;
    
public:
    LinkedNode* next() { return n; };
    int*        line() { return l; };
    
    void setNext(LinkedNode* next) { n = next; };
    void setLine(int * line)       { l = line; }
    
    
};

class Piece 
{
    
private:
    int h;
    int w;
    int** s;
    char i;
    unsigned int t; // texture handle
    
public:    
    void init(int** s_in,int h_in,int w_in, char i_in, unsigned int t_in) {
	s = s_in;
	w = w_in;
	h = h_in;
	i = i_in;
	t = t_in;
    };
    
    void  setHeight	(int h_in  ) { h = h_in;  };
    void  setWidth 	(int w_in  ) { w = w_in;  };
    void  setIcon  	(char i_in ) { i = i_in;  };
    void  setShape 	(int** s_in) { s = s_in;  };
    
    int   height() { return h;  };
    int   width()  { return w;  };
    int   icon()   { return i;  };
    int   texture(){ return t;  };
    int** shape()  { return s;  }
    
} tetri_O, tetri_L, tetri_J, tetri_T, tetri_I, tetri_S, tetri_Z;

class MenuItem {

private:
    int x;
    int y;
    
    int h;
    int w;
    
    char* name;
    
    void (*action)();
    
public:	
    init(char* name_in) {
	name = name_in;
	
	
	for (size_t i=0;i<strlen(name_in);i++) {
	    w += glutStrokeWidth(GLUT_STROKE_ROMAN, name_in[i]);
	}	
	
	h = 60;

    }
    
public: //class functions
    bool collision(int check_x, int check_y ) {
	if(check_x > x - w/4 && check_x < x + w/4 ) {
	    if(check_y > y && check_y < y + h) {
		return true;
	    }
	}
	return false;
    }
    
    void runAction() {	action(); }
    
public:	//getters
    int height() { return h; };
    int width()  { return w; };
    
    int posX() { return x; };
    int posY() { return y; };
    
    char* text() { return name; };
    
public:	//setters
    void setHeight(int h_in) { h = h_in; };
    void setWidth (int w_in) { w = w_in; };
    
    void setX (int x_in) { x = x_in; };
    void setY (int y_in) { y = y_in; };
    
    void setAction( void (*a_in)(void) ) { action = a_in; };
    
};

MenuItem mainMenu[4];
MenuItem paused[5]; 
MenuItem settings[9];

MenuItem* currentMenu;


Piece current;
Piece hold;
Piece following;


//=============== Menu Functions ===============
void startGame() 
{
    restart();
    gameState = PLAYING;
}

void settingsClick() 
{
    
}

void howTo() 
{
    gameState = HOWTO;
}

void quitGame()
{
   //are you sure?
   //glutDestroyWindow ( Win.id );
   cleanup();
   exit(0); // quit! 
}

void drawMenu() 
{
    
    
     glClear(GL_COLOR_BUFFER_BIT);	//clears to current background colour
     glColor3f(1.0f, 1.0f, 0.0f); // white
    
    int x = WORLD_X / 2;
    int y = WORLD_Y / 2;
    
	    
     
    for(int i = 0; i < 4; i++) {
	
	glPushMatrix();
	    bool selected;
	    if(mainMenu[i].collision(cursorX, cursorY)) selected = true;
	    else selected = false;
	    
	    
	    glTranslatef(mainMenu[i].posX(), mainMenu[i].posY(), 0.0f);
	    glScalef(0.5f, 0.5f, 1.0f);
	    
	    glPushMatrix();
	    
	    if(selected) glColor3f(1.0f, 1.0f, 0.0f);
	    else glColor3f(0.0f, 0.0f, 0.0f);
	    
	    glTranslatef(-mainMenu[i].width()/2, -10, 0.0f);
	    glScalef(mainMenu[i].width(), mainMenu[i].height() * 2, 1.0f);
	    draw_filled_square();
	    glPopMatrix();
	    
	    if(selected) glColor3f(0.0f, 0.0f, 0.0f);
	    else glColor3f(1.0f, 1.0f, 0.0f);
	    
	    draw_center_text(mainMenu[i].text());
	    
	    
	    
	    
	glPopMatrix();
    }
	
    
    
    
}

//=============== Drawing Functions ===============
unsigned int load_and_bind_texture(const char* filename)
{
    char* image_buffer = NULL; // the image data
	int width = 0;
	int height = 0;

	// read in the PNG image data into image_buffer
	if (png_load(filename, &width, &height, &image_buffer)==0)
    {
        fprintf(stderr, "Failed to read image texture from %s\n", filename);
        exit(1);
    }

	unsigned int tex_handle = 0;

	// request one texture handle
	glGenTextures(1, &tex_handle); 

	// create a new texture object and bind it to tex_handle
  	glBindTexture(GL_TEXTURE_2D, tex_handle);

  	glPixelStorei(GL_UNPACK_ALIGNMENT, 50);

  	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

  	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

  	glTexImage2D(GL_TEXTURE_2D, 0, 
				GL_RGB, width, height, 0,
   		 		GL_RGB, GL_UNSIGNED_BYTE, image_buffer);

	
	free(image_buffer); // free the image buffer memory
	
	return tex_handle;
}

void drawGameOver() 
{
    glPushMatrix();
	
	// translate it to where we want it
	glTranslatef(WORLD_X/2, WORLD_Y/2, 0.0f);
		    
	// scale it up 
	//glScalef(1.0f, 1.0f, 1.0f);
	glScalef(1.0, 1.0, 1.0);

	// rotate anticlockwise in-plane by 30 degrees
	glRotatef(0.0f, 0.0f, 0.0f, 1.0f); 
		    
	draw_center_text("Game Over!");
		    
    glPopMatrix(); // done with st
    
    glPushMatrix();
	
	// translate it to where we want it
	glTranslatef(WORLD_X/2, WORLD_Y / 5, 0.0f);
		    
	// scale it up 
	//glScalef(1.0f, 1.0f, 1.0f);
	glScalef(0.3f, 0.3f, 0.0f);

	// rotate anticlockwise in-plane by 30 degrees
	glRotatef(0.0f, 0.0f, 0.0f, 1.0f); 
		    
	draw_center_text("Press ENTER to return to Main Menu");
		    
    glPopMatrix(); // done with st
    
    
    
}

void drawYouWin()
{
    //draw_center_text();
}

void draw_stroke_text(const char* text) 
{
	size_t len = strlen(text);
	
	int total_width = 0;
	
	for (size_t i=0;i<len;i++) {
		total_width += glutStrokeWidth(GLUT_STROKE_ROMAN, text[i]);
		glutStrokeCharacter(GLUT_STROKE_ROMAN, text[i]);
	}	
	    
}

int draw_center_text(const char* text) 
{
	size_t len = strlen(text);
	
	int total_width = 0;
	
	for (size_t i=0;i<len;i++) {
		total_width += glutStrokeWidth(GLUT_STROKE_ROMAN, text[i]);
		
	}	
	

	
	
	glPushMatrix();
	    glTranslatef(-total_width/2, 0, 0.0f);
	    
	    for (size_t i=0;i<len;i++) {
		glutStrokeCharacter(GLUT_STROKE_ROMAN, text[i]);
	    }	
	glPopMatrix();
	    
	
	return total_width;
}

void displayFPS() 							
{
	glColor3f(1.0f, 1.0f, 0.0f); // set RGB values of colour to draw
    

	glPushMatrix(); //FPS
		glScalef(0.3f, 0.3f, 1.0f); // this will work
		glTranslatef(10, 10, 0.0f); // this will work
		
		
		string Result;          // string which will contain the result
		ostringstream convert;   // stream used for the conversion
		convert << fps;      // insert the textual representation of 'Number' in the characters in the stream
		Result = convert.str(); // set 'Result' to the contents of the stream
		
		draw_stroke_text(Result.c_str());
	glPopMatrix();	
	
}

void draw_filled_square() 
{
    
	
	static float vertex[4][2] =
		{
			{0, 1},
			{1, 1},
			{1, 0},
			{0, 0}
		};
	
	glBegin(GL_QUADS); 
		for (size_t i=0;i<4;i++) {
			
			glVertex2fv(vertex[i]);
		}
	glEnd();
	
}

void draw_square(char c) 
{
    
	glColor3f(0.0f, 0.0f, 0.0f); // set RGB values of colour to draw
    

	
	//printf('%c', c);
	
	if(!texture) {
	    switch((char) c) {
		case 'T':
		    glColor3f(1.0f, 0.0f, 1.0f); // purple
		    break;
		case 'J':
		    glColor3f(0.0f, 0.0f, 1.0f); // blue
		    break;
		case 'I':
		    glColor3f(0.0f, 1.0f, 1.0f); // light-blue
		    break;
		case 'Z':
		    glColor3f(1.0f, 0.0f, 0.0f); // red
		    break;
		case 'S':
		    glColor3f(0.0f, 1.0f, 0.0f); // green
		    break;
		case 'O':
		    glColor3f(1.0f, 1.0f, 0.0f); // yellow
		    break;
		case 'L':
		    glColor3f(1.0f, 0.5f, 0.0f); // orange
		    break;
		    
		case 'G':
		    draw_Ghost_Block();
		    return;
	    }
	} else {	  
	    //glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); 
	    glColor3f(1.0f, 1.0f, 1.0f); // black
	    
	    
	    switch((char) c) {
		case 'T':
		    glBindTexture(GL_TEXTURE_2D, tetri_T.texture());
		    break;
		case 'J':
		    glBindTexture(GL_TEXTURE_2D, tetri_J.texture());
		    break;
		case 'I':
		    glBindTexture(GL_TEXTURE_2D, tetri_I.texture());
		    break;
		case 'Z':
		    glBindTexture(GL_TEXTURE_2D, tetri_Z.texture());
		    break;
		case 'S':
		    glBindTexture(GL_TEXTURE_2D, tetri_S.texture());
		    break;
		case 'O':
		    glBindTexture(GL_TEXTURE_2D, tetri_O.texture());
		    break;
		case 'L':
		    glBindTexture(GL_TEXTURE_2D, tetri_L.texture());
		    break;
		    
		case 'G':
		    draw_Ghost_Block();
		    return;
	    }
	    
	}
	   
	
	static float vertex[4][2] =
		{
			{-1, 1},
			{1, 1},
			{1, -1},
			{-1, -1}
		};
		
		
	glBegin(GL_QUADS); 
		for (size_t i=0;i<4;i++) {
			glTexCoord2f ( (vertex[i][0] + 1) / 2,(vertex[i][1] + 1) / 2); // lower left corner
			glVertex2fv(vertex[i]);
		}
	glEnd();
	
	
	    
	    
	
	    glColor3f(0.0f, 0.0f, 0.0f); // set RGB values of colour to draw
		    
	    glBegin(GL_LINE_LOOP); 
		    for (size_t i=0;i<4;i++) {
			    
			    glVertex2fv(vertex[i]);
		    }
	    glEnd();
	
	
  	
	
	
}

void draw_Border(int d_X, int d_Y, int size_X, int size_Y) 
{
    
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
     glBegin(GL_LINE_LOOP); 
	glVertex2i(d_X , d_Y );
	glVertex2i(d_X + size_X, d_Y);
	glVertex2i(d_X + size_X, d_Y + size_Y);
	glVertex2i(d_X , d_Y + size_Y);
    glEnd();   
    
}

void draw_Ghost_Block() 
{
    
	glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
	//printf('%c', c);
	
	
	static float vertex[4][2] =
		{
			{-1, 1},
			{1, 1},
			{1, -1},
			{-1, -1}
		};
	
	glBegin(GL_LINE_LOOP); 
		for (size_t i=0;i<4;i++) {
			
			glVertex2fv(vertex[i]);
		}
	glEnd();
}

void draw_Score() 
{
    glColor3f(1.0f, 1.0f, 0.0f); // set RGB values of colour to draw
    
    glPushMatrix(); //FPS
	glTranslatef(10, WORLD_Y - 40, 0.0f); // this will work
	glScalef(0.3f, 0.3f, 1.0f); // this will work
	
	string Result;          // string which will contain the result
	ostringstream convert;   // stream used for the conversion
	convert << score;      // insert the textual representation of 'Number' in the characters in the stream
	Result = convert.str(); // set 'Result' to the contents of the stream
	
	draw_stroke_text("Score: "); 
	draw_stroke_text(Result.c_str());
    glPopMatrix();	
}

void draw_Level() 
{
    glColor3f(1.0f, 1.0f, 0.0f); // set RGB values of colour to draw
    
    glPushMatrix(); //FPS
	
	glTranslatef(10, WORLD_Y - 80, 0.0f); // this will work
	glScalef(0.3f, 0.3f, 1.0f); // this will work
	
	string Result;          // string which will contain the result
	ostringstream convert;   // stream used for the conversion
	convert << level;      // insert the textual representation of 'Number' in the characters in the stream
	Result = convert.str(); // set 'Result' to the contents of the stream
	
	draw_stroke_text("Level: "); 
	draw_stroke_text(Result.c_str());
    glPopMatrix();
}

void draw_Next() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
    int d_X = WORLD_X / 5;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
     glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Next: "); 
	
    glPopMatrix();
    
    
    draw_Border(d_X - blockSize/2 - aux_Box_S/2, d_Y + blockSize/2, aux_Box_S, -aux_Box_S );
    
    
    d_X = WORLD_X / 5 + (-1) * blockSize;
    d_Y = 0 + 20 * blockSize - 1 - (5 - following.height()) * blockSize;
    
    for(int i = 0; i < following.height(); i++) {
	for(int j = 0; j < following.width(); j++) {
	    if(following.shape()[i][j] == 1) {
		glPushMatrix();

		    // translate it to where we want it
		    glTranslatef(d_X, d_Y, 0.0f);
		    
		    glScalef(blockSize/2, blockSize/2, blockSize/2);

		    
		    draw_square(following.icon());

			
		glPopMatrix(); // done with stack
	    }
	    d_X += blockSize;
	}
	d_Y -= blockSize;
	d_X = WORLD_X / 5 + (-1) * blockSize;
    }
}

void draw_Hold() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw   
    
    int d_X = WORLD_X / 5 * 4;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
    glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Hold: "); 
	
    glPopMatrix();
    
    draw_Border(d_X - blockSize/2 - aux_Box_S/2, d_Y + blockSize/2, aux_Box_S, -aux_Box_S );
    
    d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    d_Y = 0 + 20 * blockSize - 1 - (5 - hold.height()) * blockSize;
    
    for(int i = 0; i < hold.height(); i++) {
	for(int j = 0; j < hold.width(); j++) {
	    if(hold.shape()[i][j] == 1) {
		glPushMatrix();

		    // translate it to where we want it
		    glTranslatef(d_X, d_Y, 0.0f);
		    
		    glScalef(blockSize/2, blockSize/2, blockSize/2);

		    
		    draw_square(hold.icon());

			
		glPopMatrix(); // done with stack
	    }
	    d_X += blockSize;
	}
	d_Y -= blockSize;
	d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    }
}

void draw_Board() 
{
    int d_X = WORLD_X / 5 * 2;
    int d_Y = 0 + 22 * blockSize - 1 ;
    
    draw_Border(d_X - blockSize/2 - 1, d_Y + blockSize/2 + 1, 10 * blockSize + 2, (- 20 * blockSize) - 3);
    
    for(int i = 0; i < BOARD_HEIGHT ; i++) {
	glPushMatrix();
	
	glTranslatef(d_X, d_Y - i * blockSize, 0.0f);
	
	
	for(int j = 0; j < BOARD_WIDTH; j++) {
	    if(temp[i][j] != ' ') {
	    
		glPushMatrix();

		    // translate it to where we want it
		    glTranslatef(0 + j * blockSize, 0, 0.0f);
		    
		    // scale it up 
		    //glScalef(1.0f, 1.0f, 1.0f);
		    glScalef(blockSize/2, blockSize/2, blockSize/2);

		    // rotate anticlockwise in-plane by 30 degrees
		    glRotatef(0.0f, 0.0f, 0.0f, 1.0f); 
		    
		    draw_square(temp[i][j]);
		    
		glPopMatrix(); // done with stack

	    }	    
	}
	glPopMatrix(); // done with stack
    }
}


void draw3DMain() 
{
    
   //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear color and depth buffers
   glMatrixMode(GL_MODELVIEW);     // To operate on model-view matrix
 
   // Render a color-cube consisting of 6 quads with different colors
   glLoadIdentity();                 // Reset the model-view matrix
   //glTranslatef(1.5f, 0.0f, -7.0f);  // Move right and into the screen
 
   glBegin(GL_QUADS);                // Begin drawing the color cube with 6 quads
      // Top face (y = 1.0f)
      // Define vertices in counter-clockwise (CCW) order with normal pointing out
      glColor3f(0.0f, 1.0f, 0.0f);     // Green
      glVertex3f( 1.0f, 1.0f, -1.0f);
      glVertex3f(-1.0f, 1.0f, -1.0f);
      glVertex3f(-1.0f, 1.0f,  1.0f);
      glVertex3f( 1.0f, 1.0f,  1.0f);
 
      // Bottom face (y = -1.0f)
      glColor3f(1.0f, 0.5f, 0.0f);     // Orange
      glVertex3f( 1.0f, -1.0f,  1.0f);
      glVertex3f(-1.0f, -1.0f,  1.0f);
      glVertex3f(-1.0f, -1.0f, -1.0f);
      glVertex3f( 1.0f, -1.0f, -1.0f);
 
      // Front face  (z = 1.0f)
      glColor3f(1.0f, 0.0f, 0.0f);     // Red
      glVertex3f( 1.0f,  1.0f, 1.0f);
      glVertex3f(-1.0f,  1.0f, 1.0f);
      glVertex3f(-1.0f, -1.0f, 1.0f);
      glVertex3f( 1.0f, -1.0f, 1.0f);
 
      // Back face (z = -1.0f)
      glColor3f(1.0f, 1.0f, 0.0f);     // Yellow
      glVertex3f( 1.0f, -1.0f, -1.0f);
      glVertex3f(-1.0f, -1.0f, -1.0f);
      glVertex3f(-1.0f,  1.0f, -1.0f);
      glVertex3f( 1.0f,  1.0f, -1.0f);
 
      // Left face (x = -1.0f)
      glColor3f(0.0f, 0.0f, 1.0f);     // Blue
      glVertex3f(-1.0f,  1.0f,  1.0f);
      glVertex3f(-1.0f,  1.0f, -1.0f);
      glVertex3f(-1.0f, -1.0f, -1.0f);
      glVertex3f(-1.0f, -1.0f,  1.0f);
 
      // Right face (x = 1.0f)
      glColor3f(1.0f, 0.0f, 1.0f);     // Magenta
      glVertex3f(1.0f,  1.0f, -1.0f);
      glVertex3f(1.0f,  1.0f,  1.0f);
      glVertex3f(1.0f, -1.0f,  1.0f);
      glVertex3f(1.0f, -1.0f, -1.0f);
   glEnd();  // End of drawing color-cube
 
   
  
   // Render a pyramid consists of 4 triangles
   glLoadIdentity();                  // Reset the model-view matrix
   glTranslatef(-1.5f, 0.0f, -6.0f);  // Move left and into the screen
 
   glBegin(GL_TRIANGLES);           // Begin drawing the pyramid with 4 triangles
      // Front
      glColor3f(1.0f, 0.0f, 0.0f);     // Red
      glVertex3f( 0.0f, 1.0f, 0.0f);
      glColor3f(0.0f, 1.0f, 0.0f);     // Green
      glVertex3f(-1.0f, -1.0f, 1.0f);
      glColor3f(0.0f, 0.0f, 1.0f);     // Blue
      glVertex3f(1.0f, -1.0f, 1.0f);
 
      // Right
      glColor3f(1.0f, 0.0f, 0.0f);     // Red
      glVertex3f(0.0f, 1.0f, 0.0f);
      glColor3f(0.0f, 0.0f, 1.0f);     // Blue
      glVertex3f(1.0f, -1.0f, 1.0f);
      glColor3f(0.0f, 1.0f, 0.0f);     // Green
      glVertex3f(1.0f, -1.0f, -1.0f);
 
      // Back
      glColor3f(1.0f, 0.0f, 0.0f);     // Red
      glVertex3f(0.0f, 1.0f, 0.0f);
      glColor3f(0.0f, 1.0f, 0.0f);     // Green
      glVertex3f(1.0f, -1.0f, -1.0f);
      glColor3f(0.0f, 0.0f, 1.0f);     // Blue
      glVertex3f(-1.0f, -1.0f, -1.0f);
 
      // Left
      glColor3f(1.0f,0.0f,0.0f);       // Red
      glVertex3f( 0.0f, 1.0f, 0.0f);
      glColor3f(0.0f,0.0f,1.0f);       // Blue
      glVertex3f(-1.0f,-1.0f,-1.0f);
      glColor3f(0.0f,1.0f,0.0f);       // Green
      glVertex3f(-1.0f,-1.0f, 1.0f);
   glEnd();   // Done drawing the pyramid

    
}

void draw_ASCII_Next() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw
    
    int d_X = WORLD_X / 5;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
     glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Next: "); 
	
    glPopMatrix();
        
    
    d_X = WORLD_X / 5 + (-1) * blockSize;
    d_Y = 0 + 21 * blockSize - 1 - (5 - following.height()) * blockSize;
    
    
    for(int j = 0; j < following.width(); j++) {
	  
	glPushMatrix();

	    glTranslatef(d_X + blockSize * j, d_Y, 0.0f);
	    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
	    draw_stroke_text("=") ;
    
	glPopMatrix(); // done with stack
    }
    
     d_Y -= blockSize;
     d_X = WORLD_X / 5 + (-2) * blockSize;
    
    for(int i = 0; i < following.height(); i++) {
	
	//char buffer[4];
	//buffer[0] = '[';
	//buffer[1] = ']';
	//buffer[2] = '\0';
	
	//draw_stroke_text(buffer) ;
	
	glPushMatrix();
	
	    glTranslatef(d_X, d_Y - (i + 1) * blockSize, 0.0f);	
	    
	    glPushMatrix();
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
	    
		draw_stroke_text("<!") ;
	    glPopMatrix(); // done with stack
	
	for(int j = 0; j < following.width(); j++) {
	    if(following.shape()[i][j] == 1) {
		glPushMatrix();
		    glTranslatef(blockSize + j * blockSize, 0, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);

			color_Me(following.icon());

			draw_stroke_text("[]") ;

		glPopMatrix(); // done with stack
	    }
	}
	
	    glPushMatrix();
		glTranslatef(blockSize + following.width() * blockSize  , 0, 0);	
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
	    
		draw_stroke_text("!>") ;
	    glPopMatrix(); // done with stack
	    
	
	glPopMatrix();
    }
    
    
    d_Y -= blockSize * (following.width() + 1);
    d_X = WORLD_X / 5 + (-1) * blockSize;
    
    for(int j = 0; j < following.width(); j++) {
	    
	    glPushMatrix();
		    glTranslatef(d_X, d_Y, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);

		    draw_stroke_text("=") ;

			    
	    glPopMatrix(); // done with stack
	    
	    d_X += blockSize;
	}
    
     
    
}

void draw_ASCII_Hold() 
{
    glColor3f(1.0f, 1.0f, 1.0f); // set RGB values of colour to draw   
    
    int d_X = WORLD_X / 5 * 4;
    int d_Y = 0 + 20 * blockSize - 1 ;
    
    glPushMatrix();
	glTranslatef(d_X - blockSize/2 - aux_Box_S/2, d_Y + 50, 0.0f);
	glScalef(0.3f, 0.3f, 1.0f);
	
	draw_stroke_text("Hold: "); 
	
    glPopMatrix();
    
    d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    d_Y = 0 + 21 * blockSize - 1 - (5 - hold.height()) * blockSize;
    
    
    for(int j = 0; j < hold.width(); j++) {
	  
	glPushMatrix();

	    glTranslatef(d_X + blockSize * j, d_Y, 0.0f);
	    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
	    draw_stroke_text("=") ;
    
	glPopMatrix(); // done with stack
    }
    
     d_Y -= blockSize;
    d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
     
   
    for(int i = 0; i < hold.height(); i++) {
	for(int j = 0; j < hold.width(); j++) {
	    if(hold.shape()[i][j] == 1) {
		glPushMatrix();
		
		    glTranslatef(d_X, d_Y, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		
		    color_Me(hold.icon());
		    draw_stroke_text("[]") ;
			
		glPopMatrix(); // done with stack
	    }
	    d_X += blockSize;
	}
	d_Y -= blockSize;
	d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    }
    
    
    d_Y -= blockSize;
    d_X = WORLD_X / 5 * 4 + (-1) * blockSize;
    
    for(int j = 0; j < hold.width(); j++) {
	    
	    glPushMatrix();
		    glTranslatef(d_X, d_Y, 0.0f);
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);

		    draw_stroke_text("=") ;

			    
	    glPopMatrix(); // done with stack
	    
	    d_X += blockSize;
	}
    
    
}

void draw_ASCII_Board() 
{
    
    int d_X = WORLD_X / 5 * 2 - blockSize;
    int d_Y = 0 + 22 * blockSize - 1 ;
   
    char buffer[4];
   
    for(int i = 0; i < BOARD_HEIGHT + 1 ; i++) {
	
	glPushMatrix();
	    glTranslatef(d_X, d_Y - i * blockSize, 0.0f);
	    
	    glPushMatrix();    
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		
		draw_stroke_text("<!") ;
	    glPopMatrix();
			    
	    for(int j = 0; j < BOARD_WIDTH; j++) {
		
		glTranslatef(blockSize, 0, 0.0f);
		
		glPushMatrix();
		    
		    glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		    
		    if(i >= BOARD_HEIGHT) {
			buffer[0] = '=';
			buffer[1] = '\0';
		    } else {
			if(temp[i][j] == ' ') {

			    buffer[0] = ' ';
			    buffer[1] = '.';
			    buffer[2] = '\0';
			} else {
			    
			    buffer[0] = '[';
			    buffer[1] = ']';
			    buffer[2] = '.';
			    buffer[3] = '\0';
			    //buffer[0] = temp[i][j];
			    
			    color_Me(temp[i][j]);
			    
			    if(temp[i][j] == 'G') {
				buffer[0] = '#';
				buffer[1] = '.';
				buffer[2] = '\0';
			    }   
			}
		    }
		    
		    draw_stroke_text(buffer) ;
		    
		    glColor3f(1.0f, 1.0f, 1.0f);
			
		    glPopMatrix();
		
	    }
	    glPushMatrix();

		glTranslatef( blockSize, 0, 0.0f);
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
			    
		draw_stroke_text("!>") ;
				    
	    glPopMatrix();
	
	glPopMatrix();
    }
   
    glPushMatrix();
	
	glTranslatef(d_X, d_Y - 21 * blockSize, 0.0f);
	
	for(int j = 0; j < BOARD_WIDTH; j++) {
	    
	    glPushMatrix();  
		glTranslatef(0 + (j + 1) * blockSize, 0, 0.0f);
		glScalef(blockSize/190.0, blockSize/190.0, blockSize/190.0);
		    
		draw_stroke_text("\\/") ;
		    
	    glPopMatrix(); 
	}

    glPopMatrix();
	    
}

void color_Me(char c) 
{
    
    switch(c) {
	case 'T':
	    glColor3f(1.0f, 0.0f, 1.0f); // purple
	    break;
	case 'J':
	    glColor3f(0.0f, 0.0f, 1.0f); // blue
	    break;
	case 'I':
	    glColor3f(0.0f, 1.0f, 1.0f); // light-blue
	    break;
	case 'Z':
	    glColor3f(1.0f, 0.0f, 0.0f); // red
	    break;
	case 'S':
	    glColor3f(0.0f, 1.0f, 0.0f); // green
	    break;
	case 'O':
	    glColor3f(1.0f, 1.0f, 0.0f); // yellow
	    break;
	case 'L':
	    glColor3f(1.0f, 0.5f, 0.0f); // orange
	    break;    
    }
}


void drawSettings() 
{
    
    int x = WORLD_X / 4;
    int y = 8 * (WORLD_Y / 9);
    
    glPushMatrix();
	glTranslatef(x, y, 0.0f);
	
	
	glPushMatrix();
	    glTranslatef(0, 0, 0.0f);
	    glScalef(0.5f, 0.5f, 1.0f);
	    draw_center_text(" Graphics ");
	glPopMatrix();
	
	    glPushMatrix();
		glTranslatef(x, 0, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text(" Fullscreen ");
	    glPopMatrix();
	    
	    glPushMatrix();
		glTranslatef(x, -100, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text(" Resolution ");
	    glPopMatrix();
	    
	    glPushMatrix();
		glTranslatef(x, -200, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text(" Textures ");
	    glPopMatrix();
	    
	    glPushMatrix();
		glTranslatef(x, -300, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text(" FPS Display ");
	    glPopMatrix();
	    
	    glPushMatrix();
		glTranslatef(x, -400, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text(" Render ");
	    glPopMatrix();
	
	
	
	glPushMatrix();
	    glTranslatef(0, -700, 0.0f);
	    glScalef(0.5f, 0.5f, 1.0f);
	    draw_center_text(" Game ");
	glPopMatrix();	
	
	    glPushMatrix();
		glTranslatef(x, -700, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text("Start Level");
	    glPopMatrix();
	    
	    glPushMatrix();
		glTranslatef(x, -800, 0.0f);
		glScalef(0.5f, 0.5f, 1.0f);
		draw_center_text(" Lookahead No ");
	    glPopMatrix();
	
	
    glPopMatrix();
    
    
    
}

void drawHowTo() {
    
    
    glClear(GL_COLOR_BUFFER_BIT);	//clears to current background colour
    glColor3f(1.0f, 1.0f, 1.0f); // white
    
    glEnable(GL_TEXTURE_2D); 
    glBindTexture(GL_TEXTURE_2D, howto);
    
    glBegin(GL_QUADS); 
	glTexCoord2f (0.0f,0.0f); // lower left corner
  	glVertex2i(0, 0);
  	glTexCoord2f (1.0f, 0.0f); // lower right corner
  	glVertex2i(WORLD_X, 0);
  	glTexCoord2f (1.0f, 1.0f); // upper right corner
  	glVertex2i(WORLD_X, WORLD_Y);
  	glTexCoord2f (0.0f, 1.0f); // upper left corner
  	glVertex2i(0, WORLD_Y);
    glEnd();
    
    
   
    
    glDisable(GL_TEXTURE_2D); 	
    
}


//===================== Callbacks =====================
void display() 
{
    glLoadIdentity();                 // Reset the model-view matrix
    
    frames++;
    
    glClear(GL_COLOR_BUFFER_BIT);	//clears to current background colour
    
    if (FPS) displayFPS();
    
    initGL();
    switch(gameState) {
	
	case MAINMENU:
	    initGL();
	    drawMenu();
	    break;
	case HOWTO:
	    drawHowTo();
	    break;  
	case SETTINGS:
	    drawSettings();
	    break;
	
	case PLAYING:
	    switch(graphics) {
		case VECTOR:    
		    draw_Score();
		    draw_Level();
	    
		    draw_Next();
		    draw_Hold();
		    
		    draw_Board();
		    break;
		case ASCII:
			
		    draw_Score();
		    draw_Level();
		    
		    draw_ASCII_Next();
		    draw_ASCII_Hold();
		    
		    draw_ASCII_Board();
		    break;
		case THREE_D:
		    draw3DMain();
		    break;
	    }
	    break;

	case YOUWIN:
	    drawYouWin();
	    break;
	case GAMEOVER:
	    drawGameOver();
	    break;
	case PAUSED:
	    drawMenu();
	    break;
	    
	    
	default:
	    drawMenu();
	    break;
		  
    }
      
    
    glutSwapBuffers(); 
}

void idle() 
{

    Clock::time_point now = Clock::now();
    
    milliseconds ms = chrono::duration_cast<milliseconds>(now - start);
    
    elapsed = ms.count();
    
    if( elapsed >= FPSdisplay) {
	    //cout<<frames/elapsed<<"\n";
	    fps = frames;
	    frames = 0;
	    start = Clock::now();
	    glutPostRedisplay();
	    return;
    }
    
    
    
    if(gameState == PLAYING) {
	ms = chrono::duration_cast<milliseconds>(now - lastMove);
	int elapsed = ms.count();
	    
	if(elapsed > speed[level]) {
	    lastMove = Clock::now();
	    
	    pieceY++;
	    movePiece();
	    
	    glutPostRedisplay();
	    return;
		
	}
	
	glutPostRedisplay();
    }
    
    
}

void reshape(int w, int h)
{
	/*
	// save the new window dimensions when window is resized
	WINDOW_X = w;
	WINDOW_Y = h;

  	//glViewport(0, 0, w, h);

  	glMatrixMode(GL_PROJECTION);
  	glLoadIdentity();
  	gluOrtho2D(0, w, 0, h);
  	glutPostRedisplay();
	*/
	
	/*
	 // Compute aspect ratio of the new window
	if (height == 0) height = 1;                // To prevent divide by 0
	GLfloat aspect = (GLfloat)width / (GLfloat)height;
	
	// Set the viewport to cover the new window
	glViewport(0, 0, width, height);
	
	// Set the aspect ratio of the clipping volume to match the viewport
	glMatrixMode(GL_PROJECTION);  // To operate on the Projection matrix
	glLoadIdentity();             // Reset
	// Enable perspective projection with fovy, aspect, zNear and zFar
	gluPerspective(45.0f, aspect, 0.1f, 100.0f);
	*/
	
	
}

//===================== Control =====================
void initGL() 
{
    
    fullscreen = false;
    
    FPS = true;
    
    frames = 0;
    fps = 0;
    FPSdisplay = 1000;
    
    // select viewing transformation matrix to modify
    glMatrixMode(GL_PROJECTION); 

    // set identity on matrix
    glLoadIdentity();

    // specify bottom-left and top-right corners
    // of window in world coordinates
    // takes LEFT, RIGHT, BOTTOM, TOP
    gluOrtho2D(0, WORLD_X, 0, WORLD_Y);

    // set background colour and transparency
    // takes RGBA values
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set background color to black and opaque
    
    
    
      
    glClearDepth(1.0f);                   // Set background depth to farthest
    glEnable(GL_DEPTH_TEST);   // Enable depth testing for z-culling
    glDepthFunc(GL_LEQUAL);    // Set the type of depth-test
    glShadeModel(GL_SMOOTH);   // Enable smooth shading
    
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  // Nice perspective corrections
    
    
}

int** allocateArray(int height, int width) 
{
    
    int** p = ( int** ) malloc( height *sizeof( int* ));
	for ( int i = 0; i < height; i++ ) {
	    p[i] = ( int* ) malloc( width * sizeof(int) );	
	}
    return p;
}

void gameInit() 
{
    
    howto = load_and_bind_texture("howto.png");
    
    
    mainMenu[0].init(" Start Game ");
    mainMenu[0].setAction(startGame);
    
    mainMenu[1].init(" How to Play ");
    mainMenu[1].setAction(howTo);
    
    mainMenu[2].init(" Settings ");
    mainMenu[2].setAction(settingsClick);
    
    mainMenu[3].init(" Exit ");
    mainMenu[3].setAction(quitGame);
    
    int x = WORLD_X / 2;
    int y = WORLD_Y / 2;
    
    for(int i = 0; i < 4; i++) {
	mainMenu[i].setX(x);
	mainMenu[i].setY(y - 60 * i);
	
    }
    
    /*
    settings[0].init(" Textures ");
    
    settings[1].init(" Fullscreen ");
    
    settings[2].init(" FPS Display ");
    
    settings[3].init(" Render ");
    
    settings[4].init(" Resolution ");
    
    settings[5].init(" Lookahead ");
    
    settings[6].init(" Start Level ");
    
    settings[7].init(" End Level ");
    
    settings[8].init(" Ghost Piece ");
    
    
    
     for(int i = 0; i < 9; i++) {
	settings[i].setX(x);
	settings[i].setY(y - 60 * i);
	
    }
    */
    
    
    
    
    
    
    
    
    FPS = false;
    
    gameState = GAMEOVER;
    
    blockSize = WORLD_X / 5 / 10;

    aux_Box_S = 5 * blockSize;
    
    
    level = 0;
    
    speed[0] = 53 / 60.0 * 1000;
    speed[1] = 49 / 60.0 * 1000;
    speed[2] = 45 / 60.0 * 1000;
    speed[3] = 41 / 60.0 * 1000;
    speed[4] = 37 / 60.0 * 1000;
    speed[5] = 33 / 60.0 * 1000;
    speed[6] = 28 / 60.0 * 1000;
    speed[7] = 22 / 60.0 * 1000;
    speed[8] = 17 / 60.0 * 1000;
    speed[9] = 11 / 60.0 * 1000;
    speed[10] = 10 / 60.0 * 1000;
    speed[11] = 9 / 60.0 * 1000;
    speed[12] = 8 / 60.0 * 1000;
    speed[13] = 7 / 60.0 * 1000;
    speed[14] = 6 / 60.0 * 1000;
    speed[15] = 6 / 60.0 * 1000;
    speed[16] = 5 / 60.0 * 1000;
    speed[17] = 5 / 60.0 * 1000;
    speed[18] = 4 / 60.0 * 1000;
    speed[19] = 4 / 60.0 * 1000;
    speed[20] = 3 / 60.0 * 1000;
    
    
    linesCleared = 0;
    
    lastMove = Clock::now();
    
    holdInit = false;
    gameOver = false;
    
    LinkedNode* node = new LinkedNode;
    board = node;
    
    
    for(int i = 0; i < BOARD_HEIGHT; i++) {
	
	int* line = (int*) malloc(BOARD_WIDTH * sizeof(int));
	
	for(int j = 0; j < BOARD_WIDTH; j++) {
	    line[j] = ' ';
	    temp[i][j] = ' ';
	}
	
	node->setLine(line);
	node->setNext(new LinkedNode);
	
	node = node->next();
	
    }
    
    //int* line = (int*) malloc(BOARD_WIDTH * sizeof(int));
    //node->setLine(line);
  
      
    int height;
    int width;
    char icon;
    
    
    
    
    
	height = 2;
	width = 2;
	
	int** shape_O = allocateArray(height, width);
	
	
	shape_O[0][0] = 1; shape_O[0][1] = 1;
	shape_O[1][0] = 1; shape_O[1][1] = 1;
		

    tetri_O.init(shape_O, height, width, 'O', load_and_bind_texture("square/yellow.png"));
    
		
	height = 4;
	width = 4;
	
	int** shape_I = allocateArray(height, width);
	
	shape_I[0][0] = 0; shape_I[0][1] = 1; shape_I[0][2] = 0;  shape_I[0][3] = 0;
	shape_I[1][0] = 0; shape_I[1][1] = 1; shape_I[1][2] = 0;  shape_I[1][3] = 0;
	shape_I[2][0] = 0; shape_I[2][1] = 1; shape_I[2][2] = 0;  shape_I[2][3] = 0;
	shape_I[3][0] = 0; shape_I[3][1] = 1; shape_I[3][2] = 0;  shape_I[3][3] = 0;
    
    tetri_I.init(shape_I, height, width, 'I', load_and_bind_texture("square/lightblue.png"));
    
    
	height = 3;
	width = 3;
	
	int** shape_L = allocateArray(height, width);
	
	shape_L[0][0] = 0; shape_L[0][1] = 1; shape_L[0][2] = 0;
	shape_L[1][0] = 0; shape_L[1][1] = 1; shape_L[1][2] = 0;
	shape_L[2][0] = 0; shape_L[2][1] = 1; shape_L[2][2] = 1;
	
    
    tetri_L.init(shape_L, height, width, 'L', load_and_bind_texture("square/blue.png"));
    
    
	height = 3;
	width = 3;
	
	int** shape_J = allocateArray(height, width);
	
	shape_J[0][0] = 0; shape_J[0][1] = 1; shape_J[0][2] = 0;
	shape_J[1][0] = 0; shape_J[1][1] = 1; shape_J[1][2] = 0;
	shape_J[2][0] = 1; shape_J[2][1] = 1; shape_J[2][2] = 0;
	
    
    tetri_J.init(shape_J, height, width, 'J', load_and_bind_texture("square/orange.png"));
        
    	height = 3;
	width = 3;
	
	int** shape_T = allocateArray(height, width);
	
	shape_T[0][0] = 0; shape_T[0][1] = 1; shape_T[0][2] = 0; 
	shape_T[1][0] = 1; shape_T[1][1] = 1; shape_T[1][2] = 1;
	shape_T[2][0] = 0; shape_T[2][1] = 0; shape_T[2][2] = 0;		


    tetri_T.init(shape_T, height, width, 'T', load_and_bind_texture("square/purple.png"));
      
    
    	height = 3;
	width = 3;
	
	int** shape_Z = allocateArray(height, width);
	
	shape_Z[0][0] = 1; shape_Z[0][1] = 1; shape_Z[0][2] = 0;
	shape_Z[1][0] = 0; shape_Z[1][1] = 1; shape_Z[1][2] = 1;

    
    tetri_Z.init(shape_Z, height, width, 'Z', load_and_bind_texture("square/red.png"));
    
    
    	height = 3;
	width = 3;
	
	int** shape_S = allocateArray(height, width);
	
	shape_S[0][0] = 0; shape_S[0][1] = 0; shape_S[0][2] = 0;
	shape_S[1][0] = 0; shape_S[1][1] = 1; shape_S[1][2] = 1;
	shape_S[2][0] = 1; shape_S[2][1] = 1; shape_S[2][2] = 0;
    
    tetri_S.init(shape_S, height, width, 'S', load_and_bind_texture("square/green.png"));
    
    
    
    srand (time(NULL));
    
    current = randomPiece();
    
    following = randomPiece();
    
    pieceY = 0 - current.height();
    pieceX = BOARD_WIDTH / 2;
    
    swapped = false;
    
}

void restart() 
{
    
    level = 0;
    score = 0;
    
    linesCleared = 0;
    
    holdInit = false;
    gameOver = false;
    
    
    LinkedNode* node = board;

    
     
   for(int i = 0; i < BOARD_HEIGHT; i++) {
	for(int j = 0; j < BOARD_WIDTH; j++) {
	   
		temp[i][j] = ' ';
		node->line()[j] = ' ';

	}
	
	node = node->next();
    }   
    
    current = randomPiece();
    
    following = randomPiece();
    
    pieceY = 0 - current.height();
    pieceX = BOARD_WIDTH / 2;
    
    swapped = false;
}

void freeArray(int** p, int height, int width) 
{
   
    for ( int i = 0; i < height; i++ ) {
	free(p[i]);	
    }
	
    free(p);
}

void cleanup() 
{
    
    LinkedNode* current = board;
    LinkedNode* next = board;
    
    for(int i = 0; i < BOARD_HEIGHT; i++) {	
	
	next = current->next();
	free(current);
	current = next;
    }
    
    freeArray(tetri_O.shape(), tetri_O.height(), tetri_O.width());
    
    freeArray(tetri_I.shape(), tetri_I.height(), tetri_I.width());
    
    freeArray(tetri_L.shape(), tetri_L.height(), tetri_L.width());
    
    freeArray(tetri_J.shape(), tetri_J.height(), tetri_J.width());
    
    freeArray(tetri_T.shape(), tetri_T.height(), tetri_T.width());
    
    freeArray(tetri_Z.shape(), tetri_Z.height(), tetri_Z.width());
    
    freeArray(tetri_S.shape(), tetri_S.height(), tetri_S.width());
    
    
    
    
    
}

void toggleMenu() 
{
    if(gameState == PAUSED) {
	gameState = PLAYING;   
    }else if (gameState == PLAYING) {
	gameState = PAUSED;
    }
	
}

void toggleTextures() 
{    
    if(!texture){
	glEnable(GL_TEXTURE_2D); 
	texture = true;
    } else if(texture){
	texture = false;
	glDisable(GL_TEXTURE_2D); 
    }       
}

void toggleFPS() 
{    
    if(!FPS){
	FPS = true;
    } else if(FPS){
	FPS = false;
    }       
}

void toggleFullscreen() 
{    
    if(!fullscreen){
	glutFullScreen();
	fullscreen = true;
    } else {
	glutReshapeWindow(WINDOW_X, WINDOW_Y);
	glutPositionWindow(100,100);
	fullscreen = false;
    }       
}




//=========== Game Functions ===========
void updateTemp()
{
    
    for(int i = 0; i < current.height(); i++) {
	for(int j = 0; j < current.width(); j++) {
	    //sanity check
	    if(
		pieceY + i >= 0 &&
		pieceY + i < BOARD_HEIGHT &&
		pieceX + j >= 0 && 
		pieceX + j < BOARD_WIDTH
	    ) {
		if(current.shape()[i][j] == 1) {
		    temp[pieceY + i][pieceX + j] = current.icon();
		}
	    } 
	}
    }
}

void movePiece()
{
    resetTempBoard();
    
    if(collision()) {	//place the piece and generate a new one
	pieceY--;
	
	if(pieceY < 0 ){
	    gameOver = true;
	    printf("Game Over\n");
	    restart();
	    
	    return;
	}
	
	updateBoard();
	updateTemp();
	
	newPiece();
	
    } else {  //update the draw array
    
	updateTemp();
    }
    
    calculate_Ghost();
}

void resetTempBoard()
{
    
   LinkedNode* node = board;
  
   for(int i = 0; i < BOARD_HEIGHT; i++) {
	for(int j = 0; j < BOARD_WIDTH; j++) {
	   
		temp[i][j] = node->line()[j];

	}
	
	node = node->next();
    }   
       
}

void newPiece()
{
    
    current = following;
    
    following = randomPiece();
  
    pieceY = 0 - current.height();
    pieceX = BOARD_WIDTH / 2 - current.width();
        
    swapped = false;
}

void rotateRight()
{
    
    int w = current.width();
    int h = current.height();
    
    
    int** shape_r = ( int** ) malloc( w *sizeof( int* ));
    for ( int i = 0; i < w; i++ ) {
	shape_r[i] = ( int* ) malloc( h * sizeof(int) );	
    }
    
    for(int i = 0; i < h; i++) {
	for(int j = 0; j < w; j++) {
	    shape_r[j][i] = current.shape()[i][j];
	}
    }
    
    /*
    int aux;
    for(int i = 0; i < h; i++) {
	aux = shape_r[0][i];
	shape_r[0][i] = shape_r[w-1][i];
	shape_r[w-1][i] = aux;
    }
    */
    
    int aux;
    for(int i = 0; i < w; i++) {
	aux = shape_r[i][0];
	shape_r[i][0] = shape_r[i][h -1];
	shape_r[i][h - 1] = aux;
    }
    

    
    
    //freeArray(current.shape(), h, w);
    
    current.setShape(shape_r);
    current.setHeight(w);
    current.setWidth(h);
    
   
   if(collision()) {
	
	
	
	for(int y = 0; y > -3; y--) {
	    for(int x = -2; x < 3; x++) {
		pieceY += y;
		pieceX += x;
		
		if(!collision()) {
		    return;
		} 
		
		pieceY -= y;
		pieceX -= x;
	    }
	}	    	
	
	for(int y = 1; y < 3; y++) {
	    for(int x = -2; x < 3; x++) {
		pieceY += y;
		pieceX += x;
		
		if(!collision()) {
		    return;
		} 
	    
		pieceY -= y;
		pieceX -= x;
	    }
	}
    }
    
    while(collision()) {
	pieceY--;   
   }
    
}

void rotateLeft()
{
    
    int w = current.width();
    int h = current.height();
    
    
    int** shape_r = ( int** ) malloc( w *sizeof( int* ));
    for ( int i = 0; i < w; i++ ) {
	shape_r[i] = ( int* ) malloc( h * sizeof(int) );	
    }
    
    for(int i = 0; i < h; i++) {
	for(int j = 0; j < w; j++) {
	    shape_r[j][i] = current.shape()[i][j];
	}
    }
    
    
   
    int aux;
    for(int i = 0; i < h; i++) {
	aux = shape_r[0][i];
	shape_r[0][i] = shape_r[w-1][i];
	shape_r[w-1][i] = aux;
    }
    
    
    //freeArray(current.shape(), h, w);
    
    current.setShape(shape_r);
    current.setHeight(w);
    current.setWidth(h);
    
    
   if(collision()) {
	
	for(int x = -2; x < 3; x++) {
	    for(int y = -2; y < 3; y++) {
		pieceY += y;
		pieceX += x;
		
		if(!collision()) {
		    return;
		} 
		
		pieceY -= y;
		pieceX -= x;
	    }
	}	    	
    }
   
   while(collision()) {
	pieceY--;   
   }
    
}

void holdPiece()
{
    if(swapped) {
	return;
    } else { 
	swapped = true;
    if (holdInit) {
	    Piece aux;
	    aux = hold;
	    hold = current;
	    current = aux;
	    
	    pieceY = 0 - current.height();
	    pieceX = BOARD_WIDTH / 2;

	} else {
	    
	    hold = current;
	    
	    newPiece();
	    
	    holdInit = true;
	}
    }
    
}

Piece randomPiece() 
{
      /* generate secret number between 1 and 10: */
    int r = rand() % 7 + 1;
    
     switch(r) {
	
	case 1:
	   return tetri_I;
	case 2:
	    return tetri_L;
	case 3:
	    return tetri_J;    
	case 4:
	    return tetri_O;
	case 5:
	    return tetri_S;	    
	case 6:
	    return tetri_Z;
	    break;
	case 7:
	    return tetri_T;
	    
    }
}

void calculate_Ghost() 
{
    //does the piece not fit on the board
    
    //did the piece touch another piece
    
    int ghostY = pieceY;
    
    LinkedNode* node = board;
		    
    for(int i = 0; i < ghostY; i++) {	
	node = node->next();
    } 
		    
    do {
	ghostY++;
	
	//check for collisions
	bool collision = false;
	LinkedNode* node = board;
	
	for(int i = 0; i < ghostY; i++) {	
	    node = node->next();
	}   
	
	int diff = 0;
	
	if(ghostY < 0) {
	    diff = ghostY;
	}
	    
	
	for(int i = 0; i < current.height() + diff; i++) {
	    for(int j = 0; j < current.width(); j++) {
		if(
		    ghostY + i >= 0 &&
		    pieceX + j >= 0 && 
		    pieceX + j < BOARD_WIDTH
		) {
		    if(current.shape()[i][j] == 1 && node->line()[pieceX + j] != ' ') {
			collision = true;
		    }
		    
		    if(ghostY + i >= BOARD_HEIGHT && current.shape()[i][j] == 1) {
			collision = true;
		    }
		} 	
	    }
	    
	    node = node->next();
	}
	
	if(collision) {
	    ghostY--;
	    
	    
	    for(int i = 0; i < current.height(); i++) {
		for(int j = 0; j < current.width(); j++) {
		    if(
			ghostY + i >= 0 &&
			ghostY + i < BOARD_HEIGHT &&
			pieceX + j >= 0 && 
			pieceX + j < BOARD_WIDTH
		    ) {
			if(current.shape()[i][j] == 1) {
			    if(temp[ghostY + i][pieceX + j] != current.icon()) temp[ghostY + i][pieceX + j] = 'G';
			}
		    } 
		}
	    }
	    
	    return;
	}
	
			    
    } while (ghostY != 0 - current.height());
				
}

bool collision()
{
    LinkedNode* node = board;
    
    for(int i = 0; i < pieceY; i++) {	
	node = node->next();
    }   
    
    int diff = 0;
    
    if(pieceY < 0) {
	diff = pieceY;
    }
	
    
    for(int i = 0; i < current.height() + diff; i++) {
	for(int j = 0; j < current.width(); j++) {
	    
	    if(current.shape()[i][j] == 1) {
		
		if(pieceY + i >= BOARD_HEIGHT) {
		    return true;
		}
		
		if (pieceX + j < 0 || pieceX + j >= BOARD_WIDTH) {
		    return true;
		}

		
		if(pieceY + i >= 0 && node->line()[pieceX + j] != ' ') {
		    printf("FLAG\n");
		    return true;
		}
	    }
	}
	
	node = node->next();
    }   
    
    return false;
    
}

void updateBoard()
{
         
   LinkedNode* node = board;
   LinkedNode* prev = board;
   
   int linesComepleted = 0;
    
   for(int i = 0; i < pieceY; i++) {	
	prev = node;
	node = node->next();
    }   
    
    
    for(int i = 0; i < current.height(); i++) {
	
	for(int j = 0; j < current.width(); j++) {
	    if(current.shape()[i][j] == 1) {
		node->line()[pieceX + j] = current.icon();
			
	    }
	}
	
	bool complete = true;
	    
	for(int k = 0; k < BOARD_WIDTH; k++) {
	    //printf("%c", node->line()[k]);
	    if(node->line()[k] == 32) {
		
		complete = false;
		break;
	    } 
	    
	}
	//printf("\n");
	
	if(complete) {
	    
	    
	    linesComepleted++;
	    
	    prev->setNext(node->next());
	    
	    int* line = (int*) malloc(BOARD_WIDTH * sizeof(int));
	    
	    for(int t = 0; t < BOARD_WIDTH; t++) {
		line[t] = ' ';
	    }
	    
	    LinkedNode* n = (LinkedNode*) new LinkedNode;
	    n->setNext(board);
	    n->setLine(line);
	    
	    board = n;
	    
	} else {
	    prev = node;
	}
	
	if (pieceY + i >= BOARD_HEIGHT - 1) {
	    break;
	} else {
	    node = node->next();
	}
	
    }
    
    switch(linesComepleted) {
	
	case 1: 
	    score += 40 * (level + 1);
	    break;
	case 2:
	    score += 100 * (level + 1);
	    break;
	case 3:
	    score += 300 * (level + 1);
	    break;
	case 4:
	    score += 1200 * (level + 1);
	    break;
	
    }
    
    linesCleared += linesComepleted;
    
    if(linesCleared > 10) {
	linesCleared = 0;
	level++;
	
	if(level > 20) {
	    printf("You Win!\n");
	    restart();		
	}
    }	    
}

void dropPiece() 
{
    LinkedNode* node = board;

    while(1)
    {
	pieceY++;
	if(collision()) break;
	
	score += 2;
	movePiece();    
    }
    
   
    
    resetTempBoard();   
   
}

void moveDown() 
{	
    pieceY++;   
    score++;
}

void moveLeft() 
{
    
    LinkedNode* node = board;
    
    
    for(int i = 0; i < pieceY; i++) {	
	node = node->next();
    }   
	 	    
    for(int i = 0; i < current.height(); i++) {
	for(int j = 0; j < current.width(); j++) {
	    if(pieceX - 1 + j >= 0 ) {
		if(current.shape()[i][j] == 1 && node->line()[pieceX - 1 + j] != ' ') {
		    //printf("DENIED\n");
		    return;
		}
	    } else {
		if(current.shape()[i][j] == 1) {
		    return;
		}
	    }
	}
	node = node->next();
    }
	        
    pieceX--;
}

void moveRight() 
{
    LinkedNode* node = board;
    
    for(int i = 0; i < pieceY; i++) {	
	node = node->next();
    }   
    
    for(int i = 0; i < current.height(); i++) {
	for(int j = 0; j < current.width(); j++) {
	    if(pieceX + 1 + j < BOARD_WIDTH ) {
		if(current.shape()[i][j] == 1 && node->line()[pieceX + 1 + j] != ' ') {
		    return;
		}    
	    } else if(current.shape()[i][j] == 1) {
		return;
	    }
	}
	node = node->next();
    }
    
    pieceX++;
}

//===================== Input =====================
void keyboard(unsigned char key, int x, int y) 
{ // will get which key was pressed and x and y positions if required	
	
	switch (key)
	{
		case 'q':
		    quitGame();
		    break;
		case 27:  //ESC
		    toggleMenu();
		    break;
		    
		
		    
		case 'r': 
		    restart();
		    break;
		    
		case '\r':
		    if(gameState != PLAYING) gameState = MAINMENU;
		    break;
		
		    
		case 'f': 
		    toggleFullscreen();
		    break;
		case '1':
		    toggleFPS();
		    break;
		case 't':
		    toggleTextures();
		    break; 
		   
		    
		
		case 'z': 
		    holdPiece();
		    break;
		case 'x': 
		    rotateRight();
		    break;
		case 'c': 
		    rotateLeft();
		    break;
		    
		
		case ' ': 
		    dropPiece();
		    break;
		    
		    
		case 'i': 
		    graphics = ASCII;
		    break;
		case 'o': 
		    graphics = VECTOR;
		    break;    
		case 'p': 
		    graphics = THREE_D;
		    break;
		    
	}

	movePiece();
	
	glutPostRedisplay();
}

void special(int key, int, int) 
{ //keys such as arrow keys
	// handle special keys
    
	switch (key)
	{
	  
	    case GLUT_KEY_RIGHT: 
		moveRight();
		break;
		
	    case GLUT_KEY_LEFT:
		moveLeft();
		break;
	    case GLUT_KEY_DOWN: 
		moveDown();
		break;
	    case GLUT_KEY_UP: 
		rotateRight();
		break;
		
	    case GLUT_KEY_HOME: 
		holdPiece();
		break;
		
		
	}
	movePiece();
	glutPostRedisplay(); // force a redraw
	
}

void mouse_click(int button, int state, int x, int y) 
{
    
    
	if (button==GLUT_LEFT_BUTTON) {
	    
		std::cerr << "\t left mouse button pressed!" << std::endl;
		
		if (state==GLUT_UP)
		{
			std::cerr << "\t button released...click finished" << std::endl;
			
			 for(int i = 0; i < 4; i++) {
	
			    if(mainMenu[i].collision(cursorX, cursorY)) 
				mainMenu[i].runAction();
			 }

		}
		

	} else if (button==GLUT_RIGHT_BUTTON) {
		std::cerr << "\t right mouse button pressed!" << std::endl;
		if (state==GLUT_UP) {
			std::cerr << "\t button released...click finished" << std::endl;

		}
	}
	
	glutPostRedisplay();
}

void mouse_motion(int x, int y) 
{
	y = glutGet(GLUT_WINDOW_HEIGHT) - y + 1;
    
	cursorX = x * WORLD_X / glutGet(GLUT_WINDOW_WIDTH);
	cursorY = y * WORLD_Y / glutGet(GLUT_WINDOW_HEIGHT);
	
	//std::cerr << "\t mouse is at (" << cursorX << ", " << cursorY << ")" << std::endl;
	
	glutPostRedisplay();
}


//=================== Main ===================
int main (int argc, char* argv[]) 
{
  
    //initialise glut
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA); // flags bitwise OR'd together
     
    // display window size is in pixels on screen
    glutInitWindowSize(WINDOW_X, WINDOW_Y); 
    glutInitWindowPosition(50, 50); 
    glutCreateWindow("I am glut");
    
    //callback functions
    glutDisplayFunc(display);
    //glutReshapeFunc(reshape);
    glutIdleFunc(idle);
    
    glutKeyboardFunc(keyboard); 
    glutSpecialFunc(special);
    
    glutMouseFunc(mouse_click); 
    glutPassiveMotionFunc(mouse_motion); 
    
    //initialise program
    initGL();
    gameInit();
    
    //enter infinite loop
    glutMainLoop();
    
    return 0;
  
}

